% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,openany,oneside]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{libertine}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{PyCelegans PostProcess Documentation}
\date{April 26, 2013}
\release{0.5.2}
\author{Charlie Wright}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Overview and Usage}
\label{index:overview-and-usage}\label{index:pycelegans-postprocess-documentation}
The purpose of the functions in this module are to check the output of
PyCelegans and to format it for downstream data analysis. The post-processing
code is run in two independent modes: \textbf{check} and \textbf{spline}.

\code{postprocess.py check ...}

The new integrity checks introduced are:
\begin{itemize}
\item {} 
Find frames where the midline length changes drastically

\item {} 
Find frames where the head and tail have been misidentified

\end{itemize}

In addition, integrity checks from PyCelegans are included:
\begin{itemize}
\item {} 
Frames of looped worms

\end{itemize}

To identify frames that do not fit the length requirements, the \code{checklength} module calculates the average length of the worm midline over a sliding window, and locates frames whose length deviates significantly from this value. This comparison can be performed in two modes: \emph{relative} (thresholded by number of standard deviations away from the mean) or \emph{absolute} (thresholded by actual deviation in length away from the mean).

To locate frames where the head/tail orientation is flipped, the \code{flipheadtail} module compares the current frame either (A) to the surrounding frames in a sliding window or (B) to just the previous frame. If (A), it fits each midline to a polynomial, resulting in \emph{m} x 2 (where \emph{m} is the degree of the polynomial) coefficients for each frame. These coefficients are averaged over a sliding window, and the values for each individual frame compared to this mean to find frames where the posture deviates significantly from the local value. This process is performed iteratively to account for outliers, but still relies upon the assumption that the majority of the frames within the window are correct. If the score calculate by comparing the coefficients for one frame to the local average is greater than a maximum threshold, the midline is flipped. If it is less than a minimum threshold, nothing happens. If the score falls between the minimum and maximum thresholds, it is (optionally) marked as ``indeterminate'' and rejected from further analysis. If (B), it compares the total distance between each point along the current midline and the midline of the previous frame, oriented either head-to-tail or tail-to-head. If the latter number is smaller, a flip is identified.

After running the post-process module in \code{check} mode, the number of frames that passed each check will be printed. The outputs of each integrity check are saved as a .txt file in the original \code{properties} directory.

\code{postprocess.py spline ...}

The midline is fit to a smoothing B-spline, with the option to include the results of the integrity checks. The integrity checks are included in two steps: bad frames may be rejected, and flipped worms may optionally be reoriented. If any integrity checks are missing, they are simply ignored; i.e., if \code{postprocess.py spline} if run before \code{postprocess.py check}, only the \code{is\_loop} criterion will be used. The length of the midline is also calculated by evaluating the integral of (\emph{dx}$^{\text{2}}$ + \emph{dy}$^{\text{2}}$) $^{\text{1/2}}$ along the midline. The sidepaths may be optionally splined, resulting in a closed B-spline that defines the perimeter of the worm. In this case the worm area is also calculated, by evaluating the integral of (\emph{xdy} -- \emph{ydx}) / 2 along the worm perimeter. These values, along with their corresponding frame number, are finally exported to a .mat file for analysis in Matlab. \emph{Note:} the format of the Matlab ouput will depend upon how the splines are generated; if a constant number of points are used then the midline and sidepaths will be matrices of size \emph{m} x \emph{n} x 2 where \emph{m} is the number of frames (that passed all integrity checks, if used) and \emph{n} is the number of points in the spline. If  constant spacing is used, \emph{n} may vary so the results will be cells.

After running the post-process module in \code{spline} mode, the number of frames that threw no error will be printed. If analyzing data from the \code{./properties} directory, the splined .txt files will be saved to a separate directory as well as to a .mat file (by default, \code{./processed} and \code{./processed.mat}, respectively).


\chapter{Run integrity checks}
\label{index:run-integrity-checks}
To view the help section for the integrity checks, type

\code{postprocess.py check -{-}help}

which will display:

\begin{Verbatim}[commandchars=\\\{\}]
usage: postprocess.py check [-h] [-p PROPERTIES] [-f FRAME\_RANGE FRAME\_RANGE]
                            [-v \PYGZob{}0,1\PYGZcb{}] [-ls LEN\_SPAN]
                            [-lv LEN\_MAX\_VAL \textbar{} -ld LEN\_MAX\_DEV]
                            [-fd FLIP\_DEGREE] [-fi FLIP\_ITERS] [-fs FLIP\_SPAN]
                            [-fl FLIP\_MIN\_DEV] [-fu FLIP\_MAX\_DEV]

optional arguments:
  -h, --help            show this help message and exit
  -p PROPERTIES, --properties PROPERTIES
                        properties directory; default = ./properties
  -f FRAME\_RANGE FRAME\_RANGE, --frame\_range FRAME\_RANGE FRAME\_RANGE
                        frame range, given as [first frame, last frame);
                        default = '0 inf'
  -v \PYGZob{}0,1\PYGZcb{}, --version \PYGZob{}0,1\PYGZcb{}
                        version of process code used to find midline (0 =
                        Nick's, 1 = Marc's); default = 0
  -ls LEN\_SPAN, --len\_span LEN\_SPAN
                        size of window used to check lengths, over which the
                        average worm length should be constant; default = 6000
  -lv LEN\_MAX\_VAL, --len\_max\_val LEN\_MAX\_VAL
                        maximum allowed value of length outside of average
                        value in the moving window set by the span, set as a
                        percentage; set this value but not len\_max\_dev to use
                        an absolute value of the threshold instead of
                        comparing to a deviation about the average; default =
                        0.05
  -ld LEN\_MAX\_DEV, --len\_max\_dev LEN\_MAX\_DEV
                        maximum allowed deviation of length from average value
                        of the standard score in the moving window set by the
                        span; default = 0.00
  -fd FLIP\_DEGREE, --flip\_degree FLIP\_DEGREE
                        degree used in polynomial fit to determine correct
                        orientation; default = 10
  -fi FLIP\_ITERS, --flip\_iters FLIP\_ITERS
                        number of times to run flip-check procedure; default =
                        3
  -fs FLIP\_SPAN, --flip\_span FLIP\_SPAN
                        size of window used to check flips, over which the
                        posture of the worm should be approximately constant;
                        default = 20
  -fl FLIP\_MIN\_DEV, --flip\_min\_dev FLIP\_MIN\_DEV
                        minimum deviation of coefficients used to fit worm
                        midline in moving window, below which the orientation
                        is considered correct; default = 2.00
  -fu FLIP\_MAX\_DEV, --flip\_max\_dev FLIP\_MAX\_DEV
                        maximum deviation of coefficients used to fit worm
                        midline in moving window, above which the orientation
                        is considered flipped; default = 3.00
\end{Verbatim}

To check the first 100 frames of an experiment in \code{./properties}
using Nick's midline and default parameters:

\code{postprocess.py check -p ./properties -f 0 100}

To check the frames 3000 through 4000 (inclusive), set the \code{frame\_range}:

\code{postprocess.py check -f 3000 4001}

To check every frame of an experiment using Marc's midline, set the \code{version} flag = 1:

\code{postprocess.py check -v 1}

To use a more restrictive threshold for the length-check, decrease the maximum allowed deviations by setting \code{len\_max\_val}:

\code{postprocess.py check -lv 0.02}

To use a less restrictive threshold for the length-check, increase the maximum allowed deviation by setting \code{len\_max\_val}:

\code{postprocess.py check -lv 0.1}

To use the standard score instead of the fractional change in length, set \code{len\_max\_dev}:

\code{postprocess.py check -ld 3.0}

To change the window size used to check for bad midline lengths (e.g., to 10 min at a frame rate of 10 fps), set \code{length\_span}:

\code{postprocess.py check -ls 6000}

To correct for head/tail flips without rejecting ``indeterminate'' frames, set \code{flip\_min\_dev} and \code{flip\_max\_dev} (the lower and upper thresholds, respectively) equal:

\code{postprocess.py check -fl 3.0 -fu 3.0}

To change the window size used to check for flips (e.g., to 3 sec at a frame rate of 10 fps), set \code{flip\_span} to any integer \textgreater{} 1:

\code{postprocess.py check -fs 30}

To check for flips by comparing just to the previous frame (calculating distances between points along a splined midline, instead of comparing the coefficients of the polynomial fit), set \code{flip\_span} = 1:

\code{postprocess.py check -fs 1}


\chapter{Fit to smoothing spline}
\label{index:fit-to-smoothing-spline}
To view the help section for splining the data, type

\code{postprocess.py spline -{-}help}

which will display:

\begin{Verbatim}[commandchars=\\\{\}]
usage: postprocess.py spline [-h] [-p PROPERTIES] [-f FRAME\_RANGE FRAME\_RANGE]
                             [-v \PYGZob{}0,1\PYGZcb{}] [-c] [-r] [-k] [-o OUTPUT]
                             [-s SMOOTHING] [-n NUM\_POINTS \textbar{} -sp SPACING]
                             [-l LENGTH]

optional arguments:
  -h, --help            show this help message and exit
  -p PROPERTIES, --properties PROPERTIES
                        properties directory; default = ./properties
  -f FRAME\_RANGE FRAME\_RANGE, --frame\_range FRAME\_RANGE FRAME\_RANGE
                        frame range, given as [first frame, last frame);
                        default = '0 inf'
  -v \PYGZob{}0,1\PYGZcb{}, --version \PYGZob{}0,1\PYGZcb{}
                        version of process code used to find midline (0 =
                        Nick's, 1 = Marc's); default = 0
  -c, --use\_checks      include this flag to use info from various post-
                        processing checks when calculating splines
  -r, --reorient        include this flag to reorient tail-to-head any worms
                        marked as incorrectly flipped; this flag will be
                        ignored if the '--use\_checks' flag is not used
  -k, --keep\_sides      include this flag to read the sidepaths and save a
                        single splined worm outline to file
  -o OUTPUT, --output OUTPUT
                        name of directory and .mat file to save splined data;
                        default = ./processed
  -s SMOOTHING, --smoothing SMOOTHING
                        level of smoothing in creating splined version of worm
                        midline; should be of the order of the number of
                        points in the midline; default = 25
  -n NUM\_POINTS, --num\_points NUM\_POINTS
                        number of points in the each splined worm; default =
                        100
  -sp SPACING, --spacing SPACING
                        distance between consecutive (x, y) points in each
                        splined worm; this value is exclusive of the length
                        and specifying it may result in splines with unequal
                        numbers of points; default = 0.00
  -l LENGTH, --length LENGTH
                        desired length of each splined midline; if specified
                        all splined worms will be approximately the same
                        length (depending on whether a uniform number of
                        points or spacing is given); default = 0.00
\end{Verbatim}

To spline the first 100 frames of an experiment in \code{./properties}
using Nick's midline and default parameters, and without using any automatic
corrections from the integrity checks:

\code{postprocess.py spline -f 0 100}

To spline every frame using Marc's midline without input from integrity checks:

\code{postprocess.py spline -v 1}

To include integrity checks (but ignore flips), just set the \code{use\_checks} flag:

\code{postprocess.py spline -c}

To include integrity checks (and automatically reorient tail-to-head flips), set both the \code{use\_checks} and \code{reorient} flags:

\code{postprocess.py spline -cr}

To also include sidepaths and worm areas, set the \code{keep\_sides} flag:

\code{postprocess.py spline -crk}

To make the spline smoother, increase the value of \code{smoothing}:

\code{postprocess.py spline -s 50}

To use half as many points in the midline, set the value of \code{num\_points}:

\code{postprocess.py spline -n 50}

To use a spline in which the points are spaced an equal number of pixels apart (this will produce results with a non-uniform number of points across splines), set the \code{spacing}:

\code{postprocess.py spline -sp 5.0}

\emph{Note:} if the sidepaths are also splined, they are automatically generated with twice the number of points in the midline, but with twice the smoothing factor (which should result in approximately the same amount of local smoothing).


\chapter{\texttt{postprocess} Module}
\label{index:module-postprocess}\label{index:postprocess-module}\index{postprocess (module)}\begin{description}
\item[{This is the main script for post-processing. It can run in two modes:}] \leavevmode\begin{enumerate}
\item {} 
check: run various checks on the output of PyCelegans

\item {} 
spline: spline the worm midline and export to Matlab

\end{enumerate}

\end{description}
\index{main() (in module postprocess)}

\begin{fulllineitems}
\phantomsection\label{index:postprocess.main}\pysiglinewithargsret{\code{postprocess.}\bfcode{main}}{\emph{inputs}}{}
Main function for accessing post-process functions.
\begin{description}
\item[{args:}] \leavevmode
inputs: command line inputs

\end{description}

\end{fulllineitems}



\chapter{\texttt{importdata} Module}
\label{index:importdata-module}\label{index:module-importdata}\index{importdata (module)}
Read output of PyCelegans used for further analysis: convert each midline to 
a numpy array and calculate the distance along the midline from nose to tail.
\index{getnosedist() (in module importdata)}

\begin{fulllineitems}
\phantomsection\label{index:importdata.getnosedist}\pysiglinewithargsret{\code{importdata.}\bfcode{getnosedist}}{\emph{nosetail}}{}
Calculate distance of each point along worm from nosetip.
\begin{description}
\item[{args:}] \leavevmode
nosetail (dict): dict of numpy arrays of coordinates along midline

\item[{returns:}] \leavevmode
nosedist (dict): dict of numpy arrays of distance from nose to tail

nosetail (dict): same as input, but with same set of keys as nosedist

\end{description}

\end{fulllineitems}

\index{main() (in module importdata)}

\begin{fulllineitems}
\phantomsection\label{index:importdata.main}\pysiglinewithargsret{\code{importdata.}\bfcode{main}}{\emph{path\_name, frame\_range={[}0, inf{]}, version=0}}{}
Import midline and calculate distance from nose to tail.
\begin{description}
\item[{args:}] \leavevmode
path\_name (str): name of directory containing properties .txt files

\item[{kwargs:}] \leavevmode
frame\_range (tuple): range of frames to read in given as {[}first, last)

version (int): version of PyCelegans process.py code output to use (0: 
Nick Labello's midline, 1: Marc Goessling's midline)

\item[{returns:}] \leavevmode
nosedist (dict): dict of numpy arrays of distance from nose to tail

nosetail (dict): same as input, but with same set of keys as nosedist

\end{description}

\end{fulllineitems}

\index{readnosetail() (in module importdata)}

\begin{fulllineitems}
\phantomsection\label{index:importdata.readnosetail}\pysiglinewithargsret{\code{importdata.}\bfcode{readnosetail}}{\emph{path\_name, frame\_range={[}0, inf{]}, version=0}}{}
Read worm midline (assuming nose-to-tail), converting to numpy array.
\begin{description}
\item[{args:}] \leavevmode
path\_name (str): name of directory containing properties .txt files

\item[{kwargs:}] \leavevmode
frame\_range (tuple): range of frames to read in given as {[}first, last)

version (int): version of PyCelegans process.py code output to use (0: 
Nick Labello's midline, 1: Marc Goessling's midline)

\item[{returns:}] \leavevmode
nosetail (dict): dict of numpy arrays of coordinates along midline

\end{description}

\end{fulllineitems}



\chapter{\texttt{checklength} Module}
\label{index:module-checklength}\label{index:checklength-module}\index{checklength (module)}
This module checks the output of PyCelegans by calculating the average length of the worm midline over a sliding window, and rejecting frames whose length deviates significantly from this value.
\index{checklength() (in module checklength)}

\begin{fulllineitems}
\phantomsection\label{index:checklength.checklength}\pysiglinewithargsret{\code{checklength.}\bfcode{checklength}}{\emph{nosedist}, \emph{span=6000}, \emph{max\_dev=0.0}, \emph{max\_val=0.05}}{}
Remove frames whose lengths do not fit the specified criteria: 
1. Must fall within the specified number of standard deviations from the mean, calculated over a moving window 
=\textgreater{} set max\_dev but not max\_val
2. Must fall within a constant value of the mean, calculated over a moving window
=\textgreater{} set max\_val but not max\_dev
\begin{description}
\item[{args:}] \leavevmode
nosedist (dict): dict of numpy arrays of distance from nose to tail

\item[{kwargs:}] \leavevmode
span (int): width of window

max\_dev (float): maximum allowed difference between Z-score of length

max\_val (float): maximum allowed difference between length and average

\item[{returns:}] \leavevmode
dict: dict of booleans specifying frames that pass or fail the test

\end{description}

\end{fulllineitems}

\index{main() (in module checklength)}

\begin{fulllineitems}
\phantomsection\label{index:checklength.main}\pysiglinewithargsret{\code{checklength.}\bfcode{main}}{\emph{nosedist}, \emph{span=6000}, \emph{max\_dev=0.0}, \emph{max\_val=0.05}}{}
Find frames where the length fails to meet specified criteria
\begin{description}
\item[{args:}] \leavevmode
nosedist (dict): dict of numpy arrays of distance from nose to tail

\item[{kwargs:}] \leavevmode
span (int): width of window

max\_dev (float): maximum allowed difference between Z-score of length

max\_val (float): maximum allowed difference between length and average

\item[{returns:}] \leavevmode
dict: dict of booleans specifying frames that pass or fail the test

\end{description}

\end{fulllineitems}



\chapter{\texttt{flipheadtail} Module}
\label{index:module-flipheadtail}\label{index:flipheadtail-module}\index{flipheadtail (module)}
This module checks the output of PyCelegans by determining the frames where the nose has been incorrectly identified. Each worm midline is fit to a 
polynomial, and the coefficients from each frame are compared to the
average coefficients (calculated over a sliding window) to find frames
where the posture deviates significantly from the local value. This process 
is performed iteratively to account for outliers, but still relies upon the 
assumption that the majority of the frames within the window are correct. However, if the span is just one frame, only calculate the distance between points along the worm between consecutive frames, identifying flips where this value is smaller where one of the frames has been flipped.
\index{checkflips() (in module flipheadtail)}

\begin{fulllineitems}
\phantomsection\label{index:flipheadtail.checkflips}\pysiglinewithargsret{\code{flipheadtail.}\bfcode{checkflips}}{\emph{coefs\_for}, \emph{coefs\_rev}, \emph{span=20}, \emph{min\_dev=2.0}, \emph{max\_dev=3.0}}{}
Check for nose-tail flips by comparing coefficients corresponding to worm
oriented in forward and reverse direction. When a value exceeeds the 
maximum specified deviation from the local window, flip the coefficients.
\begin{description}
\item[{args:}] \leavevmode
coefs\_for (dict): dict of coefficients corresponding to nose-to-tail

coefs\_rev (dict): dict of coefficients corresponding to tail-to-nose

\item[{kwargs:}] \leavevmode
span (int): number of points in final midline

min\_dev (float): spacing between points

max\_dev (float): dict of desired lengths of each midline

\item[{returns:}] \leavevmode
coefs\_for (dict): adjusted values of coefs\_for

coefs\_rev (dict): adjusted values of coefs\_rev

is\_flipped (dict): dict of strings with values of 
`False': no flip (value \textless{} min\_dev) 
`True': yes flip (value \textgreater{} max\_dev) 
`Indeterminate': could not determine (min\_dev \textless{} value \textless{} max\_dev)

\end{description}

\end{fulllineitems}

\index{evalpolyfit() (in module flipheadtail)}

\begin{fulllineitems}
\phantomsection\label{index:flipheadtail.evalpolyfit}\pysiglinewithargsret{\code{flipheadtail.}\bfcode{evalpolyfit}}{\emph{coefs}, \emph{num\_points=100}, \emph{spacing=None}, \emph{lengths=None}}{}
Evaluate the polynomial fit at discrete points.
There are four options for constructing the spline:
1) Same number of points, variable lengths, variable spacing
=\textgreater{} must specify only num\_points (default)
2) Variable number of points, variable lengths, same spacing
=\textgreater{} must specify only spacing
3) Same number of points, same lengths, same spacing
=\textgreater{} must specify length and either spacing or num\_points
\begin{description}
\item[{args:}] \leavevmode
coefs (dict): dict of coefficients (output of makepolyfit)

\item[{kwargs:}] \leavevmode
num\_points (int): number of points in final midline

spacing (int): spacing between points

lengths (dict): dict of desired lengths of each midline

\item[{returns:}] \leavevmode
nosedist (dict): dict of uniformly-sampled distances from nose to tail

nosetail (dict): dict of midlines evaluated using polynomial fit at 
each point in the output nosedist

\end{description}

\end{fulllineitems}

\index{main() (in module flipheadtail)}

\begin{fulllineitems}
\phantomsection\label{index:flipheadtail.main}\pysiglinewithargsret{\code{flipheadtail.}\bfcode{main}}{\emph{nosedist}, \emph{nosetail}, \emph{degree=10}, \emph{num\_iters=3}, \emph{span=20}, \emph{min\_dev=2.0}, \emph{max\_dev=3.0}, \emph{smoothing=25}, \emph{num\_points=100}}{}
Find frames where head/tail identification has failed by making a 
polynomial representation of the worm and comparing the value of the 
coefficients frame-by-frame to the average in a sliding window. If the size of the sliding window is set to just one frame however, do not fit to a polynomial but instead calculate the Euclidean distance between points along splined worms in consecutive frames, counting a flip if the norm between `forward' and `reverse' is smaller than between both `forward'.
\begin{description}
\item[{args:}] \leavevmode
nosedist (dict): dict of numpy arrays of distance from nose to tail

nosetail (dict): dict of numpy arrays of coordinates along midline

\item[{kwargs:}] \leavevmode
degree (int): degree of polynomial fit

num\_iters (int): number of times to repeat the head/tail flip check

span (int): number of points in final midline

min\_dev (float): spacing between points

max\_dev (float): dict of desired lengths of each midline

\item[{returns:}] \leavevmode
is\_flipped (dict): dict of strings with values of 
`False': no flip (value \textless{} min\_dev)
`True': yes flip (value \textgreater{} max\_dev)
`Indeterminate': could not determine (min\_dev \textless{} value \textless{} max\_dev)

\end{description}

\end{fulllineitems}

\index{makepolyfit() (in module flipheadtail)}

\begin{fulllineitems}
\phantomsection\label{index:flipheadtail.makepolyfit}\pysiglinewithargsret{\code{flipheadtail.}\bfcode{makepolyfit}}{\emph{nosedist}, \emph{nosetail}, \emph{degree=10}}{}
Fit the midline to a polynomial.
\begin{description}
\item[{args:}] \leavevmode
nosedist (dict): dict of numpy arrays of distance from nose to tail

nosetail (dict): dict of numpy arrays of coordinates along midline

\item[{kwargs:}] \leavevmode
degree (int): degree of polynomial fit

\item[{returns:}] \leavevmode
dict: dict of coefficients, each of which is m X 2 array for m degrees

\end{description}

\end{fulllineitems}



\chapter{\texttt{splinefit} Module}
\label{index:splinefit-module}\label{index:module-splinefit}\index{splinefit (module)}
Construct a uniformly-sampled B-spline of the worm, given the set of points running along the worm midline from nosetip to tailtip and the distance between each of those points.
\index{evalbspline() (in module splinefit)}

\begin{fulllineitems}
\phantomsection\label{index:splinefit.evalbspline}\pysiglinewithargsret{\code{splinefit.}\bfcode{evalbspline}}{\emph{tcks}, \emph{num\_points=100}, \emph{spacing=0.0}, \emph{lengths=None}}{}
Evaluate the spline at discrete points.    
There are three options for constructing the spline: 
1) Same number of points, variable lengths, variable spacing 
=\textgreater{} must specify num\_points (default) and each length 
2) Variable number of points, variable lengths, same spacing 
=\textgreater{} must specify spacing and each length 
3) Same number of points, same lengths, same spacing 
=\textgreater{} must specify all same length and either spacing or num\_points
\begin{description}
\item[{args:}] \leavevmode
tcks (dict): dict of spline fit (knots, coefs, degree)

\item[{kwargs:}] \leavevmode
num\_points (int): number of points in final midline

spacing (int): spacing between points

lengths (dict): dict of desired lengths of each midline

\item[{returns:}] \leavevmode
nosedist (dict): dict of uniformly-sampled distances from nose to tail

nosetail (dict): dict of midlines evaluated using polynomial fit at 
each point in the output nosedist

\end{description}

\end{fulllineitems}

\index{main() (in module splinefit)}

\begin{fulllineitems}
\phantomsection\label{index:splinefit.main}\pysiglinewithargsret{\code{splinefit.}\bfcode{main}}{\emph{us}, \emph{vs}, \emph{smoothing=25}, \emph{num\_points=100}, \emph{spacing=0.0}, \emph{length=0.0}, \emph{per=0}}{}
Fit the worm to a smoothing B-spline.
\begin{description}
\item[{args:}] \leavevmode
us (array): euclidean distance between points

vs (array): array of (x, y) points

\item[{kwargs:}] \leavevmode
smoothing (int): smoothing

num\_points (int): number of points in final midline

spacing (int): spacing between points

lengths (dict): dict of desired lengths of each midline

per (int): set non-zero for a closed spline, i.e., periodic b.c.

\item[{returns:}] \leavevmode
nosedist (dict): dict of uniformly-sampled distances from nose to tail

nosetail (dict): dict of midlines evaluated using polynomial fit at 
each point in the output nosedist

\end{description}

\end{fulllineitems}

\index{makebspline() (in module splinefit)}

\begin{fulllineitems}
\phantomsection\label{index:splinefit.makebspline}\pysiglinewithargsret{\code{splinefit.}\bfcode{makebspline}}{\emph{us}, \emph{vs}, \emph{s=25}, \emph{per=0}}{}
Fit the a series of (x, y) coordinates to a smoothing B-spline.
\begin{description}
\item[{args:}] \leavevmode
us (array): euclidean distance between points

vs (array): array of (x, y) points

\item[{kwargs:}] \leavevmode
s (int): smoothing

per (int): set non-zero for a closed spline, i.e., periodic boundary
conditions (default = 0)

\item[{returns:}] \leavevmode
dict: dict of spline fit (knots, coefs, degree)

\end{description}

\end{fulllineitems}



\chapter{\texttt{calc} Module}
\label{index:module-calc}\label{index:calc-module}\index{calc (module)}
This module contains miscellaneous functions for time series data analysis.
\index{fullmovingavg() (in module calc)}

\begin{fulllineitems}
\phantomsection\label{index:calc.fullmovingavg}\pysiglinewithargsret{\code{calc.}\bfcode{fullmovingavg}}{\emph{data}, \emph{span=5}}{}
Moving average, padded on ends with original data.
\begin{description}
\item[{args:}] \leavevmode
data (iterable): data sequence (1D)

\item[{kwargs:}] \leavevmode
span (int): width of window

\item[{returns:}] \leavevmode
list: output of func applied to data over the sliding window is a list  
of the same size as the input data, where instead of padding the ends 
of the output, the average is calculated but over a smaller window 
until reaching the ends of the sequence

\end{description}

\end{fulllineitems}

\index{moving() (in module calc)}

\begin{fulllineitems}
\phantomsection\label{index:calc.moving}\pysiglinewithargsret{\code{calc.}\bfcode{moving}}{\emph{data}, \emph{func=\textless{}function mean at 0x10de0bd70\textgreater{}}, \emph{span=5}}{}
Calculate the value of the function in a moving (sliding) window.
\begin{description}
\item[{args:}] \leavevmode
data (iterable): data sequence (1D)

\item[{kwargs:}] \leavevmode
func: name of function (default = np.mean)

span (int): width of window

\item[{returns:}] \leavevmode
list: output of func applied to data over the sliding window is a list 
of the same size as the input data, where the ends are padded with the 
first and last values of the input data

\end{description}

\end{fulllineitems}

\index{window() (in module calc)}

\begin{fulllineitems}
\phantomsection\label{index:calc.window}\pysiglinewithargsret{\code{calc.}\bfcode{window}}{\emph{seq}, \emph{n=2}}{}
Returns a sliding window (of width n) over data from the iterable
s -\textgreater{} (s0,s1,...s{[}n-1{]}), (s1,s2,...,sn), ...
From itertools examples.
\begin{description}
\item[{args:}] \leavevmode
seq (iterable): data sequence

\item[{kwargs:}] \leavevmode
n (int): width of window (default = 2)

\item[{returns:}] \leavevmode
iter: sliding window

\end{description}

\end{fulllineitems}



\chapter{\texttt{parseargs} Module}
\label{index:module-parseargs}\label{index:parseargs-module}\index{parseargs (module)}
This module creates the argument parser for accepting command line inputs.
\index{addchecklength() (in module parseargs)}

\begin{fulllineitems}
\phantomsection\label{index:parseargs.addchecklength}\pysiglinewithargsret{\code{parseargs.}\bfcode{addchecklength}}{\emph{parser}}{}
Add arguments to parser for checklength.py

\end{fulllineitems}

\index{addflipheadtail() (in module parseargs)}

\begin{fulllineitems}
\phantomsection\label{index:parseargs.addflipheadtail}\pysiglinewithargsret{\code{parseargs.}\bfcode{addflipheadtail}}{\emph{parser}}{}
Add arguments to parser for flipheadtail.py

\end{fulllineitems}

\index{addimportdata() (in module parseargs)}

\begin{fulllineitems}
\phantomsection\label{index:parseargs.addimportdata}\pysiglinewithargsret{\code{parseargs.}\bfcode{addimportdata}}{\emph{parser}}{}
Add arguments to parser for importdata.py

\end{fulllineitems}

\index{addsplinefit() (in module parseargs)}

\begin{fulllineitems}
\phantomsection\label{index:parseargs.addsplinefit}\pysiglinewithargsret{\code{parseargs.}\bfcode{addsplinefit}}{\emph{parser}}{}
Add arguments to parser for splinefit.py

\end{fulllineitems}

\index{main() (in module parseargs)}

\begin{fulllineitems}
\phantomsection\label{index:parseargs.main}\pysiglinewithargsret{\code{parseargs.}\bfcode{main}}{\emph{inputs}}{}
\end{fulllineitems}



\chapter{\texttt{readwrite} Module}
\label{index:module-readwrite}\label{index:readwrite-module}\index{readwrite (module)}
This module contains functions for reading and writing PyCelegans output data.
\index{readtxt() (in module readwrite)}

\begin{fulllineitems}
\phantomsection\label{index:readwrite.readtxt}\pysiglinewithargsret{\code{readwrite.}\bfcode{readtxt}}{\emph{path\_name}, \emph{parameter}, \emph{frame\_range=(0}, \emph{inf)}, \emph{data\_type=\textless{}type `float'\textgreater{}}}{}
Read data from text file, e.g., .txt output of collectoutput.py.
The expected input format is that each line contains data separated by 
commas, with the first value corresponding to the frame number.
The output is a dictionary with keys corresponding to frame numbers
and values corresponding to the data contained in each line.
\begin{description}
\item[{args:}] \leavevmode
path\_name (str): name of directory containing properties .txt files

parameter (str): name of parameter (file name minus extension)

\item[{kwargs:}] \leavevmode
frame\_range (tuple): range of frames to read in given as {[}first, last)
will read in all data from file)

data\_type: expected data type

\item[{returns:}] \leavevmode
dict: dict of values; keys are frame numbers

\end{description}

\end{fulllineitems}

\index{reformat() (in module readwrite)}

\begin{fulllineitems}
\phantomsection\label{index:readwrite.reformat}\pysiglinewithargsret{\code{readwrite.}\bfcode{reformat}}{\emph{data\_dict}}{}
Reformat data dictionary for saving to Matlab. Convert all dictionaries
to lists, and construct a new value called frames that corresponds to
the full set of keys for each variable.
\begin{description}
\item[{args:}] \leavevmode
data\_dict: dict of dicts

\item[{returns:}] \leavevmode
dict: dict of lists

\end{description}

\end{fulllineitems}

\index{savemat() (in module readwrite)}

\begin{fulllineitems}
\phantomsection\label{index:readwrite.savemat}\pysiglinewithargsret{\code{readwrite.}\bfcode{savemat}}{\emph{file\_name}, \emph{data\_dict}}{}
Reformat so that dictionaries become lists and save to .mat file. 
Input is dictionary of values, i.e., \{`midline':..., `nosetip':..., \}
\begin{description}
\item[{args:}] \leavevmode
file\_name (str): name of .mat file to save data

data\_dict (dict): dict of dicts

\end{description}

\end{fulllineitems}

\index{writetxt() (in module readwrite)}

\begin{fulllineitems}
\phantomsection\label{index:readwrite.writetxt}\pysiglinewithargsret{\code{readwrite.}\bfcode{writetxt}}{\emph{path\_name}, \emph{parameter}, \emph{data\_dict}, \emph{frames=}\optional{}, \emph{data\_format='\%0.1f'}}{}
Write data to text file. The exact inverse of the read function.
The inputs are the parameter name (while determines the file name)
and the data dictionary, and a string describing how to convert
the data values to text (e.g., \%0.4f for float, \%r for boolean).
\begin{description}
\item[{args:}] \leavevmode
path\_name (str): name of directory containing properties .txt files

parameter (str): name of parameter (file name minus extension)

data\_dict (dict): dict of values; keys are frame numbers

\item[{kwargs:}] \leavevmode
frames (list): list of frames to write to file. If the data\_dict does 
not have a key corresponding to each frame in this list then an 
error (-1) will be written. If this input is empty, all values 
from data\_dict will be written

data\_format: how to format each value to string

\end{description}

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{c}
\item {\texttt{calc}}, \pageref{index:module-calc}
\item {\texttt{checklength}}, \pageref{index:module-checklength}
\indexspace
\bigletter{f}
\item {\texttt{flipheadtail}}, \pageref{index:module-flipheadtail}
\indexspace
\bigletter{i}
\item {\texttt{importdata}}, \pageref{index:module-importdata}
\indexspace
\bigletter{p}
\item {\texttt{parseargs}}, \pageref{index:module-parseargs}
\item {\texttt{postprocess}}, \pageref{index:module-postprocess}
\indexspace
\bigletter{r}
\item {\texttt{readwrite}}, \pageref{index:module-readwrite}
\indexspace
\bigletter{s}
\item {\texttt{splinefit}}, \pageref{index:module-splinefit}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
